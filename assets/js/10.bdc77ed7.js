(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{453:function(t,a,e){"use strict";e.r(a);var s=e(16),l=Object(s.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"html5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html5"}},[t._v("#")]),t._v(" HTML5")]),t._v(" "),e("h2",{attrs:{id:"html5-新特性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html5-新特性"}},[t._v("#")]),t._v(" HTML5 新特性：")]),t._v(" "),e("ul",[e("li",[t._v("绘图方面：加入了 canvas 绘图和 SVG 绘图；")]),t._v(" "),e("li",[t._v("媒体方面： 加入了 video 和 audio 标签")]),t._v(" "),e("li",[t._v("语义化标签： 比如 header、nav、footer、section ['sekʃ(ə)n]、article ['ɑrtɪkl]")]),t._v(" "),e("li",[t._v("本地离线存储： localStorage[ˈloʊkl] 和 sessionStory 两种本地离线缓存\n"),e("ul",[e("li",[t._v("localStorage 是长期储存数据,关闭浏览器后数据不会丢失")]),t._v(" "),e("li",[t._v("sessionStorage 是关闭浏览器后数据自动删除")])])]),t._v(" "),e("li",[t._v("表单控件: calendar、date、time、email、url、search ;")]),t._v(" "),e("li",[t._v("一些新技术: webwoker / websocket (säkit)/ GelolCation(ˌjēōlōˈkāSHən)")])]),t._v(" "),e("h2",{attrs:{id:"如何区分-html-和-html5"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何区分-html-和-html5"}},[t._v("#")]),t._v(" 如何区分 HTML 和 HTML5:")]),t._v(" "),e("p",[t._v("通过 Doctype 声明/新增的结构元素/功能元素")]),t._v(" "),e("h2",{attrs:{id:"浏览器是怎么对-html5-的离线储存资源进行管理和加载的"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浏览器是怎么对-html5-的离线储存资源进行管理和加载的"}},[t._v("#")]),t._v(" 浏览器是怎么对 HTML5 的离线储存资源进行管理和加载的？")]),t._v(" "),e("ol",[e("li",[t._v("在线的情况下，浏览器发现 html 标签有 manifest 属性，它会请求 manifest 文件")]),t._v(" "),e("li",[t._v("如果是第一次访问 app，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储")]),t._v(" "),e("li",[t._v("如果已经访问过 app 且资源已经离线存储了，浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作。如果文件改变了，那么就会重新下载文件中的资源并进行离线存储")]),t._v(" "),e("li",[t._v("离线的情况下，浏览器就直接使用离线存储的资源。")])]),t._v(" "),e("h2",{attrs:{id:"html5-离线缓存怎么使用-工作原理能不能解释一下"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html5-离线缓存怎么使用-工作原理能不能解释一下"}},[t._v("#")]),t._v(" HTML5 离线缓存怎么使用，工作原理能不能解释一下？")]),t._v(" "),e("p",[t._v("用户在没有联网时，可以正常访问站点或应用，等用户联网时，更新用户的缓存文件\n浏览器是怎么对 HTML5 进行离线缓存资源进行管理和加载的?：在联网情况下，html 头部有 manifest 属性，会请求 manifest 文件，如果是第一次访问，浏览器会根据 manifest 的内容下载相应的资源并且进行离线缓存，如果不是第一个，会加载成为新的 manifest 文件，新旧 manifest 文件对比，如果一致，则不发生变化，如果不一致，那么会重新下载文件中的资源并进行离线缓存")]),t._v(" "),e("h2",{attrs:{id:"描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#描述一下-cookies-sessionstorage-和-localstorage-的区别"}},[t._v("#")]),t._v(" 描述一下 cookies/sessionStorage 和 localStorage 的区别?")]),t._v(" "),e("p",[t._v('cookies 是网站为了表示用户身份而储存在用户本地终端上的数据,Cookies 的数据始终在同源的 http 请求中携带,会在浏览器和服务器中来回传递,大小不能 4K(通常经过加密,所以不用担心账号被盗,同源策略[同源是指"协议+域名+端口"三者相同]可以防止 XSS 和 CSRF 攻击浏览器,XSS 就是用过浏览器的 cookies,截取用户数据,CSRF 是模拟用户在网页上面的操作,完成数据请求.异步策略牵扯到了 JSONP)\nsessionStorage 和 localStory 的数据都是在本地存储,不会把数据发给服务器,localStorage 是关闭浏览器,数据还存在不会丢失,而 sessionStorage 是离开浏览器后,数据会自动删除.')]),t._v(" "),e("h2",{attrs:{id:"如何实现浏览器内多个标签之间的通信"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何实现浏览器内多个标签之间的通信"}},[t._v("#")]),t._v(" 如何实现浏览器内多个标签之间的通信?")]),t._v(" "),e("ol",[e("li",[t._v("Websocket['sɒkɪt]/SharedWorker 都是可以将不同线程共享为一个线程,他们的数据也是共享的(没怎么用过,用法不太清楚)")]),t._v(" "),e("li",[t._v("LocalStorage 也可以实现浏览器多个标签页之间的通信")]),t._v(" "),e("li",[t._v("localStorage 在另一个浏览器被添加/删除/修改时,会触发一个事件,我们可以通过对 loacalStorage 监听事件,控制他的值来进行信息通信")])]),t._v(" "),e("h2",{attrs:{id:"title-和-h1-的区别-b-与-strong-的区别-i-和-em-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#title-和-h1-的区别-b-与-strong-的区别-i-和-em-的区别"}},[t._v("#")]),t._v(" Title 和 h1 的区别,b 与 strong 的区别,i 和 em 的区别?")]),t._v(" "),e("p",[t._v("title 属性没有明确的标题,只是 HTML 语义化的一个标签,而 h1 则是层次明确的标题,h1 标签里的文字,字体较大,并且会加粗\nb 与 strong 都有加粗字体的作用,strong 只是更加语义化,是加重语气的意思\ni 和 em,em 是强化文本的内容,而所有浏览器对重要内容都是以斜体形式显示的,i 则是表示,标签内文本为斜体")])])}),[],!1,null,null,null);a.default=l.exports}}]);